void setupProjectionMatrix(GLuint shaderProgram) {
    glm::mat4 projection = glm::ortho(-1.0f, 1.0f, -1.0f, 1.0f);
    GLint projLoc = glGetUniformLocation(shaderProgram, "projection");
    glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(projection));
}

#version 330 core
layout(location = 0) in vec2 aPos;

uniform mat4 projection;

void main() {
    gl_Position = projection * vec4(aPos, 0.0, 1.0);
}

int main() {
    if (!glfwInit()) {
        return -1;
    }

    GLFWwindow* window = glfwCreateWindow(1920, 1080, "Ray Transfer Matrix", NULL, NULL);
    if (!window) {
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cerr << "Failed to initialize GLAD" << std::endl;
        return -1;
    }

    // Create and compile your shader program
    GLuint shaderProgram = createShaderProgram(); // Assume you have a function to create your shader program

    // Set up the projection matrix
    setupProjectionMatrix(shaderProgram);

    while (!glfwWindowShouldClose(window)) {
        drawRayExample();
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}

void drawRayExample() {
    // Use the shader program
    glUseProgram(shaderProgram);

    // Set the background color to white
    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    // Set the line color to black
    glColor3f(0.0f, 0.0f, 0.0f);

    // Set the point size
    glPointSize(5.0);

    glBegin(GL_POINTS);
    glVertex2f(0.0f, 0.0f); // Draw a point at the origin
    glEnd();

    RayTransferMatrixBuilder rtmb = RayTransferMatrixBuilder();
    float initialPos = 0.0f;
    glm::vec2 initialRay = glm::vec2(0.5f, 10.0f); // First term is displacement to the optical axis, second term is the angle

    //DRAW RAY AT INITIAL POS
    glBegin(GL_LINES);
    glVertex2f(initialPos, initialRay.x);
    glVertex2f(initialPos + 0.1f * cos(toRad(initialRay.y)), initialRay.x + 0.1f * sin(toRad(initialRay.y))); // Scale down the ray length
    glEnd();

    // Set the line color to red
    glColor3f(1.0f, 0.0f, 0.0f);

    float di = 0.5f;
    glm::mat2x2 tMat = rtmb.getTranslationMatrix(di);
    glm::vec2 transformedRay = tMat * initialRay;
    float transformedPos = initialPos + di;

    glBegin(GL_POINTS);
    glVertex2f(transformedPos, 0.0f);
    glEnd();

    //DRAW TRANSFORMED RAY
    glBegin(GL_LINES);
    glVertex2f(transformedPos, transformedRay.x);
    glVertex2f(transformedPos + 0.1f * cos(toRad(transformedRay.y)), transformedRay.x + 0.1f * sin(toRad(transformedRay.y))); // Scale down the ray length
    glEnd();

    glFlush();
}
